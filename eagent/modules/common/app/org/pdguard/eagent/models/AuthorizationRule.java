/*-
 * Copyright 2014-2015 Thodoris Sotiropoulos
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package org.pdguard.eagent.models;

import com.avaje.ebean.Model;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.pdguard.api.utils.DataType;
import play.Play;
import play.data.validation.Constraints;
import play.libs.Json;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.UniqueConstraint;
import javax.persistence.Table;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

/**
 * This class defines the entity of AuthorizationRule for database schema of
 * this application using Ebean ORM.
 *
 * An authorization rule defines the way data of a subject which are stored to a
 * data controller organization should be used by organization. Therefore, an
 * authorization rule defines the allowable actions that should be performed on
 * specific data of a subject by a specific application of an organization.
 *
 * For instance, an application of organization A can read address of subject B
 * but it cannot export address to a file.
 *
 * For different data types of a specific subject there are different allowable
 * actions that should be performed by an application. These actions are defined
 * by the subject to whom data belongs.
 *
 * For that purpose, there is an relation with the {@link DataSubject}
 * class declaring as @ManyToOne. This means that each authorization rule is
 * defined by one data subject and one data subject can define multiple
 * authorization rules. As mentioned above, these authorization rules are
 * related to different types of subject's data.
 *
 * Apart from this, there is also an relation with the {@link DataController}
 * class declaring as @ManyToOne. This means that each authorization rule
 * associated with one data controller, and one data controller is associated
 * with multiple authorization rules.
 *
 * There is also a relation with the {@link AllowableAction} class declaring as
 * OneToMany. This means that each authorization rule defines multiple
 * allowable ways of using data and one allowable action is associated with one
 * authorization rule.
 *
 * Finally, there is a relatiom with the {@link AllowableProvenance} class
 * declaring as @OneToMany. This means that each authorization rule defines
 * multiple allowable provenances of data and one allowable provenance is
 * associated with one authorization rule only.
 *
 * @author Thodoris Sotiropoulos
 */
@Table(uniqueConstraints = @UniqueConstraint(
        columnNames = {"data_subject_id", "data_controller_id", "data_type"}))
@Entity
public class AuthorizationRule extends Model {
    /** Id of entity. Declared as a primary key. Generated by database. */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    /** The type of the data. This field is required. */
    @Constraints.Required
    @Column(nullable = false)
    private DataType dataType;

    /**
     * Mapping with the {@link DataController} entity with as ManyToOne
     * relation. Each type of personal data is associated with one
     * data controller. This field is required.
     */
    @Constraints.Required
    @ManyToOne(optional = false)
    private DataController dataController;

    /**
     * Mapping with the {@link AllowableAction} entity with as OneToMany
     * relation. Each type of personal data has multiple ways of being used.
     * This field is required.
     */
    @OneToMany(mappedBy = "authorizationRule", cascade = CascadeType.ALL)
    private Set<AllowableAction> allowableActions = new HashSet<>();

    /**
     * Mapping with the {@link AllowableProvenance} entity with as OneToMany
     * relation. Each type of personal data has multiple provenances where
     * they can be obtained from. This field is required.
     */
    @OneToMany(mappedBy = "authorizationRule", cascade = CascadeType.ALL)
    private Set<AllowableProvenance> allowableProvenances = new HashSet<>();

    /**
     * Mapping with the {@link DataSubject} entity with as ManyToOne
     * relation. Each authorization rule is defined by one data subject. This
     * field is required.
     */
    @Constraints.Required
    @ManyToOne(optional = false)
    private DataSubject dataSubject;

    /**
     * This field will be used to programatically make queries which return
     * object of this class.
     */
    private static Finder<Integer, AuthorizationRule> finder = new Finder<>(
            AuthorizationRule.class);

    /**
     * Creates an object of PersonalData with all required fields associated
     * with it.
     *
     * @param dataController Data controller who is associated with this
     * authorization rule.
     * @param dataSubject Data subject who defines this authorization rule.
     * @param dataType The type of the data.
     */
    public AuthorizationRule(final DataSubject dataSubject,
            final DataController dataController, final DataType dataType) {
        this.dataSubject = dataSubject;
        this.dataController = dataController;
        this.dataType = dataType;
    }

    /**
     * This method checks and retrieves the authorization rules associated with
     * a specific data subject, data controller and data type.
     *
     * @param dataSubjectId Id of data subject.
     * @param dataControllerId Id of data controller.
     * @param dataType Type of data.
     *
     * @return Type of data with all authorization rules associated with it.
     */
    public static AuthorizationRule authenticate(final String dataSubjectId,
            final String dataControllerId, final DataType dataType) {
        return AuthorizationRule.finder.where()
                .eq("dataSubject.id", dataSubjectId)
                .eq("dataController.id", dataControllerId)
                .eq("dataType", dataType).findUnique();
    }

    /**
     * This methods saves authorization rule to the escrow agent's database
     * with the default rule.
     *
     * Default rule does not define any way in which data controller can use
     * the personal data of data subject. Therefore, it is required data subject
     * set the allowable actions which can be performed to their data.
     */
    public void addDefaultAuthRule() {
        allowableActions.add(new AllowableAction(this, null, new Date(), null));
        allowableProvenances.add(new AllowableProvenance(this, null,
                new Date(), null));
        this.save();
        /*
         * Create default auth rule for the category
         * (if it does not already exist) of this type of data too.
         */
        if (dataType.getParent() != null && AuthorizationRule.authenticate(
                dataSubject.getId(), dataController.getId(),
                (DataType) dataType.getParent()) == null) {
            new AuthorizationRule(dataSubject, dataController, (DataType)
                    dataType.getParent()).addDefaultAuthRule();
        }
    }

    /**
     * This method returns Authorization rules of data subject.
     *
     * Given the email of data subject, this method searches for all
     * authorization rules which were defined by this specific data subject and
     * stores them into a list of json objects.
     *
     * @param dataSubjectEmail Email of data subject.
     * @return List of json objects containing the authorization rules.
     */
    public static List<ObjectNode> getDataSubjectAuthRules(
            final String dataSubjectEmail) {
        List<ObjectNode> jsonObjects = new LinkedList<>();
        List<AuthorizationRule> data = AuthorizationRule.finder.where()
                .eq("dataSubject.dataSubjectEmail", dataSubjectEmail)
                .findList();
        for (AuthorizationRule authRule : data) {
            ObjectNode dataTypes = Json.newObject();
            dataTypes.put("dataType", authRule.getDataType()
                    .toString());
            dataTypes.put("dataController", authRule
                    .getDataController().getDataControllerName());
            dataTypes.set("actions", AllowableAction.parseAllowableActions(
                    authRule.allowableActions));
            dataTypes.set("provenances", AllowableProvenance
                    .parseAllowableProvenances(authRule.allowableProvenances));
            jsonObjects.add(dataTypes);
        }
        return jsonObjects;
    }

    /**
     * This method locks personal data of a subject.
     *
     * When a data subject locks specific data of them (for example, a data
     * subject locks their credit card number), then data controller who holds
     * these data, they cannot have any access to them (neither read nor
     * update). Data subject can permit access to their data again by redefining
     * the authorization rule.
     */
    public void lockData() {
        lockActions(allowableActions.iterator());
        lockProvenances(allowableProvenances.iterator());
    }

    /**
     * This method deletes all allowable actions related to an authorization
     * rule so that a data controller cannot read data.
     *
     * @param iter Iterator of allowable actions.
     */
    static void lockActions(final Iterator<AllowableAction> iter) {
        while (iter.hasNext()) {
            AllowableAction authAllowableAction = iter.next();
            if (iter.hasNext()) {
                authAllowableAction.delete();
                iter.remove();
            }
            else
                authAllowableAction.setDefaultAuthRule();
        }
    }

    /**
     * This method deletes all allowable provenances related to an authorization
     * rule so that a data controller cannot update data.
     *
     * @param iter Iterator of allowable provenances.
     */
    static void lockProvenances(final Iterator<AllowableProvenance> iter) {
        while (iter.hasNext()) {
            AllowableProvenance authAllowableAction = iter.next();
            if (iter.hasNext()) {
                authAllowableAction.delete();
                iter.remove();
            }
            else
                authAllowableAction.setDefaultAuthRule();
        }
    }

    /**
     * This method loads the default authorization rules from the corresponding
     * file and then  creates a JSON object.
     *
     * @return JSON object of the default authorization rules.
     */
    public static JsonNode getDefaultAuthRules() {
        final String path = Play.application().path().getAbsolutePath()
                + "/../../data/auth-rules/default_rules.json";
        StringBuilder response = new StringBuilder();
        String output;
        BufferedReader br = null;
        try {
            br = new BufferedReader(new InputStreamReader(
                    new FileInputStream(path), "UTF-8"));
            while ((output = br.readLine()) != null)
                response.append(output);
        } catch (IOException e) {
            return null;
        } finally {
            try {
                if (br != null)
                    br.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return Json.parse(response.toString());
    }

    /** Updates an existing authorization rule. */
    public void updateAuthRule() {
        this.update();
    }

    /**
     * Getter of id field.
     *
     * @return Id of authorization rule.
     */
    public Integer getId() {
        return this.id;
    }

    /**
     * Getter of dataType field.
     *
     * @return Type of data.
     */
    public DataType getDataType() {
        return dataType;
    }

    /**
     * Getter of dataController field.
     *
     * @return Data controller who's associated with authorization rule.
     */
    public DataController getDataController() {
        return dataController;
    }

    /**
     * Setter of dataController field.
     *
     *
     * @param dataController Data controller who's associated with authorization
     * rule.
     */
    public void setDataController(final DataController dataController) {
        this.dataController = dataController;
    }

    /**
     * Getter of dataSubject field.
     *
     * @return Data subject who's associated with authorization rule.
     */
    public DataSubject getDataSubject() {
        return dataSubject;
    }

    /**
     * Getter of rules field.
     *
     * @return Authorization rules which define the way this personal data
     * can be used.
     */
    public Set<AllowableAction> getAllowableActions() {
        return allowableActions;
    }

    /**
     * Getter of allowableProvenances field.
     *
     * @return Allowable provenances of data.
     */
    public Set<AllowableProvenance> getAllowableProvenances() {
        return allowableProvenances;
    }

    /**
     * Setter of dataType field.
     *
     * @param dataType Type of data.
     */
    public void setDataType(final DataType dataType) {
        this.dataType = dataType;
    }

    /**
     * Getter of finder field.
     *
     * @return It will be used to programatically make queries which return
     * object of this class.
     */
    public static Finder<Integer, AuthorizationRule> getFinder() {
        return finder;
    }
}
