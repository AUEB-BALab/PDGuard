/*-
 * Copyright 2014-2015 Thodoris Sotiropoulos
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package org.pdguard.eagent.models;

import com.avaje.ebean.Model;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.pdguard.api.utils.DataType;
import org.pdguard.api.utils.DataUse;
import org.pdguard.eagent.common.PeriodValidity;
import play.data.format.Formats;
import play.data.validation.Constraints;
import play.libs.Json;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.UniqueConstraint;
import javax.persistence.Table;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Set;

/**
 * This class defines the entity of AllowableAction for database schema of
 * this application using Ebean ORM.
 *
 * An allowable action defines the correct usage of data belongs to a data
 * subject by data controllers.
 *
 * For instance, an application of organization A can read address of subject B
 * but it cannot export address to a file.
 *
 * For different data types of a specific subject there are different allowable
 * actions that should be performed by an application. These actions are defined
 * by the subject to whom data belongs.
 *
 * For that purpose, there is an relation with the {@link AuthorizationRule}
 * class declaring as @ManyToOne. This means that each allowable action is
 * associated with and describes one type of personal data stored by one
 * specific data controller and it belongs to one data subject. Moreover, each
 * authorization rule defines multiple allowable ways of using data.
 *
 * @author Thodoris Sotiropoulos
 */
@Table(uniqueConstraints = @UniqueConstraint(
        columnNames = {"authorization_rule_id", "data_use"}))
@Entity
public final class AllowableAction extends Model implements PeriodValidity {
    /** Id of entity. Declared as a primary key. Generated by database. */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    /** The allowable action which can be performed on data subject's data. */
    @Column
    private DataUse dataUse;

    /** Date when authorization rule is valid from. This field is required. */
    @Constraints.Required
    @Formats.DateTime(pattern = "yyyy-MM-dd")
    @Column(nullable = false)
    private Date validFrom;

    /** Date when authorization rule expires. This field is required. */
    @Constraints.Required
    @Formats.DateTime(pattern = "yyyy-MM-dd")
    @Column(nullable = false)
    private Date validTo;

    /**
     * Mapping with the {@link AuthorizationRule} entity with as ManyToOne
     * relation. Each allowable action is defined for one authorization rule
     * only. This field is required.
     */
    @Constraints.Required
    @ManyToOne(optional = false)
    private AuthorizationRule authorizationRule;

    /**
     * This field will be used to programatically make queries which return
     * object of this class.
     */
    private static Finder<Integer, AllowableAction> finder = new Finder<>(
            AllowableAction.class);

    /**
     * Initializes an allowable action performed on personal data with
     * information associated with it.
     *
     * @param authorizationRule Personal data associated with this authorization
     * rule.
     * @param dataUse The allowable action which can be performed on data
     * subject's data.
     * @param validFrom Date when authorization rule is valid from.
     * @param validTo Date when authorization rule expires.
     */
    public AllowableAction(final AuthorizationRule authorizationRule,
            final DataUse dataUse, final Date validFrom, final Date validTo) {
        this.authorizationRule = authorizationRule;
        this.dataUse = dataUse;
        this.validFrom = validFrom;
        if (validTo == null)
            // Set default expiration date.
            this.validTo = getExpirationDate(validFrom);
        else
            this.validTo = validTo;
    }

    /**
     * This method sets default authorization rule.
     *
     * By default all authorization rules do not include any allowable actions
     * performed on data they are associated.
     */
    public void setDefaultAuthRule() {
        final int infinityYear = 9999;
        final int day = 31;
        Calendar calendar = Calendar.getInstance();
        calendar.set(infinityYear, Calendar.DECEMBER, day);
        setDataUse(null);
        setValidFrom(new Date());
        setValidTo(calendar.getTime());
        update();
    }

    /**
     * Checks if a data controller who is requesting escrow agent for decrypting
     * specific data of a specific subject is allowed to use it with the way he
     * defines.
     *
     * For example, suppose that someone is requesting escrow agent to decrypt
     * Facebook Id of a subject in order to export it to a file. This method
     * checks if they have the authorization to do such an action.
     *
     * @param dataSubjectId Id of data subject.
     * @param dataControllerId Id of data controller.
     * @param dataType Type of data.
     * @param dataUse The intended use of the decrypted data.
     *
     * @return True if a data controller can use data with the way defined by
     * this rule, false otherwise.
     */
    public static boolean isAuthorized(final String dataSubjectId,
            final String dataControllerId, final DataType dataType,
            final DataUse dataUse) {
        AuthorizationRule authorizationRule = AuthorizationRule.authenticate(
                dataSubjectId, dataControllerId, dataType);
        if (authorizationRule == null)
            return false;
        AllowableAction authAllowableAction = AllowableAction.finder.where()
                .eq("authorizationRule.id", authorizationRule.getId())
                .eq("dataUse", dataUse)
                .findUnique();
        if (authAllowableAction != null)
            return !authAllowableAction.isExpired(authAllowableAction
                    .getValidFrom(), authAllowableAction.getValidTo());
        return false;
    }

    /**
     * Checks if a data controller who is requesting escrow agent for decrypting
     * specific data of a specific subject is allowed to use it with the way he
     * defines.
     *
     * Allowable actions are defined by the default authorization rules
     * according to the escrow agent's policy.
     *
     * For example, suppose that someone is requesting escrow agent to decrypt
     * Facebook Id of a subject in order to export it to a file. This method
     * checks if they have the authorization to do such an action.
     *
     * @param dataType Type of data.
     * @param dataUse The intended use of the decrypted data.
     *
     * @return True if a data controller can use data with the way defined by
     * this rule, false otherwise.
     */
    public static boolean isAuthorized(final DataType dataType,
            final DataUse dataUse) {
        JsonNode authRules = AuthorizationRule.getDefaultAuthRules();
        if (authRules == null)
            return false;
        JsonNode allowableActions = authRules.get(
                dataType.toString()).get("actions");
        return allowableActions.toString().contains(dataUse.toString());
    }

    /**
     * This methods saves a new allowable action to the escrow agent's database.
     *
     * Allowable action defines the way in which data controller
     * can use the personal data of data subject.
     *
     * For example, it defines that the email address of a data subject can
     * be stored to a file.
     *
     * @return Id of allowable action, 0 if allowable action was not created
     * successfully.
     */
    public int addAllowableAction() {
        if (authorizationRule.getAllowableActions().contains(this))
            return 0;
        if (authorizationRule.getAllowableActions().size() == 1
                && authorizationRule.getAllowableActions()
                .iterator().next().getDataUse() == null) {
            /*
             * When there is not any allowable action defined previously on
             * the type of data which data controller stores encrypted just
             * update the existing record.
             */
            AllowableAction definedAllowableAction = authorizationRule
                    .getAllowableActions().iterator().next();
            definedAllowableAction.setDataUse(dataUse);
            definedAllowableAction.setValidTo(validTo);
            definedAllowableAction.setValidFrom(validFrom);
            definedAllowableAction.getAuthorizationRule().update();
            return definedAllowableAction.getId();
        } else {
            authorizationRule.getAllowableActions().add(this);
            authorizationRule.update();
            return id;
        }
    }

    /**
     * This method updates the parameters which describes an authorization rule
     * of a data subject.
     *
     * Data subject redefines their authorization rules by updating the
     * allowable action performed on specific data, time when authorization rule
     * is valid or the data controller.
     *
     * @param id The id of the authorization rule to update.
     *
     * @return Exit code, 0 if authorization rule is updated successfully; 1
     * otherwise.
     */
    public int updateAllowableAction(final int id) {
        this.id = id;
        if (authorizationRule.getAllowableActions().contains(this))
            return 1;
        AllowableAction authAllowableAction = getDefinedAuthRule(
                authorizationRule, id);
        if (authAllowableAction == null)
            return 1;
        authAllowableAction.setDataUse(dataUse);
        authAllowableAction.setValidFrom(validFrom);
        authAllowableAction.setValidTo(validTo);
        authAllowableAction.update();
        authAllowableAction.authorizationRule.update();
        return 0;
    }

    /**
     * This method deletes an existing allowable action.
     *
     * Data subject deletes an allowable action which they have previously
     * defined. There is one extreme case: If there is only one allowable action
     * associated with a specific data type of a data subject and a data
     * controller, then deletion is completed only by locking these data to
     * data controller's read operations performed on these data.
     *
     * @param id The id of the action rule to delete.
     *
     * @return Exit code, 0 if action rule is deleted successfully; 1
     * otherwise.
     */
    public static int deleteAllowableAction(final int id) {
        AllowableAction authAllowableAction = AllowableAction.getFinder()
                .where().eq("id", id).findUnique();
        if (authAllowableAction == null)
            return 1;
        if (authAllowableAction.getAuthorizationRule()
                .getAllowableActions().size() > 1) {
            authAllowableAction.delete();
            return 0;
        } else {
            authAllowableAction.setDefaultAuthRule();
            return 0;
        }
    }

    /**
     * This method retrieves an authorization rule stored into
     * escrow agent's database associated with the type of data, data subject
     * and data controller defined by the object as well as unique id defined
     * by the method's parameter.
     *
     * @param authorizationRule Authorization rule.
     * @param id ID of authorization rule to be retrieved.
     *
     * @return Existing Authorization rule; otherwise null.
     */
    public static AllowableAction getDefinedAuthRule(
            final AuthorizationRule authorizationRule, final int id) {
        return AllowableAction.getFinder().where()
                .eq("authorizationRule.id", authorizationRule.getId())
                .eq("id", id)
                .findUnique();
    }

    /**
     * Convert a Set of Allowable actions to a JSON array.
     *
     * @param allowableActions Set of allowable actions.
     *
     * @return A JSON array of allowable actions.
     */
    public static ArrayNode parseAllowableActions(
            final Set<AllowableAction> allowableActions) {
        DateFormat dateForm = new SimpleDateFormat("yyyy-MM-dd");
        ArrayNode actions = Json.newArray();
        for (AllowableAction authAllowableAction : allowableActions) {
            ObjectNode rule = Json.newObject();
            rule.put("id", authAllowableAction.getId());
            rule.put("dataUse", authAllowableAction.getDataUse() == null
                    ? null : authAllowableAction.getDataUse().toString());
            rule.put("validFrom", dateForm.format(authAllowableAction
                    .getValidFrom()));
            rule.put("validTo", dateForm.format(authAllowableAction
                    .getValidTo()));
            actions.add(rule);
        }
        return actions;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        AllowableAction that = (AllowableAction) o;

        return dataUse == that.dataUse
                && id != null ? !id.equals(that.id) : that.id != null;

    }

    @Override
    public int hashCode() {
        return dataUse != null ? dataUse.hashCode() : 0;
    }

    /**
     * Getter of id field.
     *
     * @return Id of authorization rule.
     */
    public Integer getId() {
        return this.id;
    }

    /**
     * Getter of dataUse field.
     *
     * @return The allowable action which can be performed on data subject's
     * data.
     */
    public DataUse getDataUse() {
        return dataUse;
    }

    /**
     * Setter of dataUse field.
     *
     * @param dataUse The allowable action which can be performed on data
     * subject's data.
     */
    public void setDataUse(final DataUse dataUse) {
        this.dataUse = dataUse;
    }

    /**
     * Setter of validFrom field.
     *
     * @param validFrom Date when authorization rule is valid from.
     */
    public void setValidFrom(final Date validFrom) {
        this.validFrom = validFrom;
    }

    /**
     * Setter of validTo field.
     *
     * @param validTo Date when authorization rule expired.
     */
    public void setValidTo(final Date validTo) {
        this.validTo = validTo;
    }

    /**
     * Getter of validFrom field.
     *
     * @return Date when authorization rule is valid from.
     */
    public Date getValidFrom() {
        return validFrom;
    }

    /**
     * Getter of validTo field.
     *
     * @return Date when authorization rule expires.
     */
    public Date getValidTo() {
        return validTo;
    }

    /**
     * Getter of personalData field.
     *
     * @return Personal data associated with this authorization rule.
     */
    public AuthorizationRule getAuthorizationRule() {
        return authorizationRule;
    }

    /**
     * Getter of finder field.
     *
     * @return It will be used to programatically make queries which return
     * object of this class.
     */
    public static Finder<Integer, AllowableAction> getFinder() {
        return finder;
    }
}
