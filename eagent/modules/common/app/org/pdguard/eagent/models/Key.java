/*-
 * Copyright 2014-2015 Thodoris Sotiropoulos
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package org.pdguard.eagent.models;

import static org.apache.commons.codec.binary.Hex.encodeHex;

import org.pdguard.eagent.common.PeriodValidity;
import play.data.format.Formats;
import play.data.validation.Constraints;
import com.avaje.ebean.Model;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.UniqueConstraint;
import javax.persistence.Table;

import java.security.NoSuchAlgorithmException;
import java.util.Date;

/**
 * This class defines the entity of EncryptionKey for database schema of this
 * application using Ebean ORM.
 *
 * An encryption key is used by data controller organization in order to encrypt
 * and decrypt personal data of a subject. These data are stored encrypted to
 * database of organization.
 *
 * When someone wants to have access to some encrypted data, they request escrow
 * agent for this encryption key which is stored to database of escrow agent.
 * This encryption key corresponds to one subject to whom encrypted personal
 * data belongs and it also corresponds to many data controllers who request
 * escrow agent for accessing data.
 *
 * For that purpose, there is an relation with the {@link DataSubject}
 * class declaring as @ManyToOne. This means that each data subject owns
 * many keys for decryption and encryption of his data, and one key belongs to
 * one data subject.
 *
 * Apart from this, there is also an relation with the {@link DataController}
 * class declaring as @OneToMany. This means that each data controller uses
 * multiple keys for the encryption and decryption of a subject's data and one
 * key is associated with only one data controller.
 *
 * @author Thodoris Sotiropoulos
 */
@Table(uniqueConstraints = @UniqueConstraint(
        columnNames = {"data_subject_id", "data_controller_id"}))
@Entity
public class Key extends Model implements Cloneable,
        PeriodValidity {
    /** Id of entity. Declared as a primary key. Generated by database. */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    /**
     * Content of key in sequence bytes encoded to hexadecimal system. This
     * field is required.
     */
    @Constraints.Required
    @Column(nullable = false)
    private byte[] keyContent;

    /** Date when encryption key is valid from. This field is required. */
    @Constraints.Required
    @Formats.DateTime(pattern = "yyyy-MM-dd")
    @Column(nullable = false)
    private Date validFrom;

    /** Date when key expired. This field is required. */
    @Constraints.Required
    @Formats.DateTime(pattern = "yyyy-MM-dd")
    @Column(nullable = false)
    private Date validTo;

    /**
     * Mapping with the {@link DataController} entity with as ManyToOne
     * relation. Each encryption key is associated with one data controller.
     * This field is required.
     */
    @ManyToOne(optional = false, cascade = CascadeType.ALL)
    private DataController dataController;

    /**
     * Mapping with the {@link DataSubject} entity with as ManyToOne
     * relation. Each encryption key belongs to one data subject.
     */
    @ManyToOne(optional = false, cascade = CascadeType.ALL)
    private DataSubject dataSubject;

    /**
     * This field will be used to programatically make queries which return
     * object of this class.
     */
    private static Finder<Integer, Key> finder = new Finder<>(
            Key.class);

    /**
     * Default constructor.
     */
    public Key() { }

    /**
     * Initialized an encryption key with the information associated with it.
     *
     * @param dataSubject Data subject who owns a encryption key.
     * @param dataController Data controller who is associated with this
     * encryption key.
     * @param validFrom Date when encryption key is valid from.
     */
    public Key(final DataSubject dataSubject,
               final DataController dataController, final Date validFrom) {
        this.dataSubject = dataSubject;
        this.dataController = dataController;
        this.keyContent = this.createKey();
        this.validFrom = validFrom;
        this.validTo = getExpirationDate(validFrom);
    }

    /**
     * Adds an encryption key to database of escrow agent.
     */
    public void addKey() {
        this.save();
    }

    /**
     * Generates a new symmetric key based on AES encryption system. Then a
     * sequence of bytes of key content in hexadecimal system is returned.
     *
     * @return A sequence of bytes of key content in hexadecimal system.
     */
    public byte[] createKey() {
        SecretKey aesKey;
        try {
            aesKey = KeyGenerator.getInstance("AES").generateKey();
        } catch (NoSuchAlgorithmException e) {
            return new byte[0];
        }
        assert aesKey != null;
        return aesKey.getEncoded();
    }

    /**
     * Checks if there any encryption key stored in database of escrow agent and
     * associated with data subject and data controller which are defined by the
     * with ids given as parameters.
     *
     * @param dataSubjectId Id of data subject.
     * @param dataControllerId Id of data controller.
     *
     * @return Encryption key.
     */
    public static Key loadKey(final String dataSubjectId,
            final String dataControllerId) {
        if (dataControllerId == null || dataSubjectId == null)
            return null;
        return Key.finder.where()
                .eq("dataController.id", dataControllerId)
                .eq("dataSubject.id", dataSubjectId)
                .findUnique();
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    /**
     * Getter of id field.
     *
     * @return Id of encryption key.
     */
    public Integer getId() {
        return this.id;
    }

    /**
     * Getter of data controller field.
     *
     * @return Data controller who is associated with this encryption key.
     */
    public DataController getDataController() {
        return dataController;
    }

    /**
     * Setter of dataController field.
     *
     * @param dataController Data controller who is associated with this
     * encryption key.
     */
    public void setDataController(final DataController dataController) {
        this.dataController = dataController;
    }

    /**
     * Getter of dataSubject field.
     *
     * @return Data subject who owns this encryption key.
     */
    public DataSubject getDataSubject() {
        return dataSubject;
    }

    /**
     * Gets key content in an encoded String format.
     *
     * @return Content of key in an encoded String format.
     */
    public String getKeyContent() {
        char[] hex = encodeHex(this.keyContent);
        return String.valueOf(hex);
    }

    /**
     * Getter of keyContent field.
     *
     * @return Content of key in binary format.
     */
    public byte[] getEncodedKeyContent() {
        return keyContent;
    }

    /**
     * Setter of keyContent field.
     *
     * @param keyContent Content of key in sequence bytes encoded to hexadecimal
     * system.
     */
    public void setKeyContent(final byte[] keyContent) {
        this.keyContent = keyContent;
    }

    /**
     * Getter of validFrom field.
     *
     * @return Date when encryption key is valid from.
     */
    public Date getValidFrom() {
        return validFrom;
    }

    /**
     * Setter of validFrom field.
     *
     * @param validFrom Date when encryption key is valid from.
     */
    public void setValidFrom(final Date validFrom) {
        this.validFrom = validFrom;
    }

    /**
     * Getter of validTo field.
     *
     * @return Date when encryption key expires.
     */
    public Date getValidTo() {
        return validTo;
    }

    /**
     * Getter of validTo field.
     *
     * @param validTo Date when encryption key expires.
     */
    public void setValidTo(final Date validTo) {
        this.validTo = validTo;
    }

    /**
     * Getter of finder field.
     *
     * @return It will be used to programatically make queries which return
     * object of this class.
     */
    public static Finder<Integer, Key> getFinder() {
        return finder;
    }
}
