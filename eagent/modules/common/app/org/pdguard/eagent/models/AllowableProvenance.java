/*-
 * Copyright 2014-2015 Thodoris Sotiropoulos
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package org.pdguard.eagent.models;

import com.avaje.ebean.Model;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.pdguard.api.utils.DataProvenance;
import org.pdguard.api.utils.DataType;
import org.pdguard.eagent.common.PeriodValidity;
import play.data.format.Formats;
import play.data.validation.Constraints;
import play.libs.Json;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.UniqueConstraint;
import javax.persistence.Table;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Set;

/**
 * This class defines the entity of AllowableAction for database schema of
 * this application using Ebean ORM.
 *
 * An allowable provenance defines the sources where data controller
 * organization can obtain personal data of a data subject.
 *
 * For instance, an application is allowed to encrypt home address of a
 * data subject taken from a web form.
 *
 * For different data types of a specific subject there are different allowable
 * provenances. These provenances are defined by the subject to whom data
 * belongs.
 *
 * For that purpose, there is an relation with the {@link AuthorizationRule}
 * class declaring as @ManyToOne. This means that each allowable provenance is
 * associated with and describes one type of personal data stored by one
 * specific data controller and it belongs to one data subject. Moreover, each
 * authorization rule defines multiple allowable provenances of data.
 *
 * @author Thodoris Sotiropoulos
 */
@Table(uniqueConstraints = @UniqueConstraint(
        columnNames = {"authorization_rule_id", "data_provenance"}))
@Entity
public final class AllowableProvenance extends Model
        implements PeriodValidity {
    /** Id of entity. Declared as a primary key. Generated by database. */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    /** The allowable source of data. */
    @Column
    private DataProvenance dataProvenance;

    /** Date when authorization rule is valid from. This field is required. */
    @Constraints.Required
    @Formats.DateTime(pattern = "yyyy-MM-dd")
    @Column(nullable = false)
    private Date validFrom;

    /** Date when authorization rule expires. This field is required. */
    @Constraints.Required
    @Formats.DateTime(pattern = "yyyy-MM-dd")
    @Column(nullable = false)
    private Date validTo;

    /**
     * Mapping with the {@link AuthorizationRule} entity with as ManyToOne
     * relation. Each allowable provenance is defined for one authorization rule
     * only. This field is required.
     */
    @Constraints.Required
    @ManyToOne(optional = false)
    private AuthorizationRule authorizationRule;

    /**
     * This field will be used to programatically make queries which return
     * object of this class.
     */
    private static Finder<Integer, AllowableProvenance> finder = new Finder<>(
            AllowableProvenance.class);

    /**
     * Initializes an allowable provenance of data with the associated
     * information.
     *
     * @param authRule Personal data associated with this restriction.
     * @param dataProvenance Allowable source of data.
     * @param validFrom Date when validity period starts.
     * @param validTo Date when validity period ends.
     */
    public AllowableProvenance(final AuthorizationRule authRule,
            final DataProvenance dataProvenance, final Date validFrom,
            final Date validTo) {
        authorizationRule = authRule;
        this.dataProvenance = dataProvenance;
        this.validFrom = validFrom;
        if (validTo == null)
            // Set default expiration date.
            this.validTo = getExpirationDate(validFrom);
        else
            this.validTo = validTo;
    }

    /**
     * Checks if a data controller who is requesting escrow agent for encrypting
     * specific data of a specific subject is allowed to update it based on
     * the source where it obtained from.
     *
     * For example, suppose that someone is requesting escrow agent to encrypt
     * the home address of a data subject taken from a web form. This method
     * checks if they have the authorization to do such an action.
     *
     * @param dataSubjectId Id of data subject.
     * @param dataControllerId Id of data controller.
     * @param dataType Type of data.
     * @param dataProvenance The data's provenance; where the data was obtained
     * from.
     *
     * @return True if a data controller can use data with the way defined by
     * this rule, false otherwise.
     */
    public static boolean isAuthorized(final String dataSubjectId,
            final String dataControllerId, final DataType dataType,
            final DataProvenance dataProvenance) {
        AuthorizationRule authorizationRule = AuthorizationRule.authenticate(
                dataSubjectId, dataControllerId, dataType);
        if (authorizationRule == null)
            return false;
        AllowableProvenance allowableProvenance = AllowableProvenance
                .finder.where()
                .eq("authorizationRule.id", authorizationRule.getId())
                .eq("dataProvenance", dataProvenance)
                .findUnique();
        if (allowableProvenance != null)
            return !allowableProvenance.isExpired(allowableProvenance
                    .getValidFrom(), allowableProvenance.getValidTo());
        return false;
    }

    /**
     * Checks if a data controller who is requesting escrow agent for decrypting
     * specific data of a specific subject is allowed to store data obtained
     * from the given provenance
     *
     * Allowable provenances are defined by the default authorization rules
     * according to the escrow agent's policy.
     *
     * For example, suppose that someone is requesting escrow agent to store
     * Credit card number of a subject taken from the data subject himself. This
     * method checks if they have the authorization to do such an action.
     *
     * @param dataType Type of data.
     * @param dataProvenance Where the data obtained from.
     *
     * @return True if a data controller can use data with the way defined by
     * this rule, false otherwise.
     */
    public static boolean isAuthorized(final DataType dataType,
            final DataProvenance dataProvenance) {
        JsonNode authRules = AuthorizationRule.getDefaultAuthRules();
        if (authRules == null)
            return false;
        JsonNode allowableProvenances = authRules.get(
                dataType.toString()).get("provenances");
        return allowableProvenances.toString().contains(dataProvenance
                .toString());
    }

    /**
     * Convert a Set of Allowable Provenances objects to a JSON array.
     *
     * @param allowableProvenances Set of allowable provenances.
     *
     * @return A JSON array of allowable provenances.
     */
    public static ArrayNode parseAllowableProvenances(
            final Set<AllowableProvenance> allowableProvenances) {
        DateFormat dateForm = new SimpleDateFormat("yyyy-MM-dd");
        ArrayNode provenances = Json.newArray();
        for (AllowableProvenance allowableProvenance : allowableProvenances) {
            ObjectNode rule = Json.newObject();
            rule.put("id", allowableProvenance.getId());
            rule.put("dataProvenance", allowableProvenance
                    .getDataProvenance() == null ? null : allowableProvenance
                    .getDataProvenance().toString());
            rule.put("validFrom", dateForm.format(allowableProvenance
                    .getValidFrom()));
            rule.put("validTo", dateForm.format(allowableProvenance
                    .getValidTo()));
            provenances.add(rule);
        }
        return provenances;
    }

    /**
     * This methods saves a new allowable provenance to the escrow agent's
     * database.
     *
     * Allowable provenance defines the provenance where data should be obtained
     * from.
     *
     * For example, it defines that the email address of a data subject which
     * was taken from the data subject behaviour is allowed to be stored by
     * data controller organization.
     *
     * @return Id of allowable provenance, 0 if allowable provenance was not
     * created successfully.
     */
    public int addAllowableProvenance() {
        if (authorizationRule.getAllowableProvenances().contains(this))
            return 0;
        if (authorizationRule.getAllowableProvenances().size() == 1
                && authorizationRule.getAllowableProvenances()
                .iterator().next().getDataProvenance() == null) {
            /*
             * When there is not any allowable provenance defined previously on
             * the type of data which data controller stores encrypted just
             * update the existing record.
             */
            AllowableProvenance allowableProvenance = authorizationRule
                    .getAllowableProvenances().iterator().next();
            allowableProvenance.setDataProvenance(dataProvenance);
            allowableProvenance.setValidTo(validTo);
            allowableProvenance.setValidFrom(validFrom);
            allowableProvenance.getAuthorizationRule().update();
            return allowableProvenance.getId();
        } else {
            authorizationRule.getAllowableProvenances().add(this);
            authorizationRule.update();
            return id;
        }
    }

    /**
     * This method updates the parameters which describes an allowable
     * provenance associated with the data of a data subject.
     *
     * Data subject redefines their authorization rules by updating the
     * allowable provenance of specific data, time when authorization rule
     * is valid or the data controller.
     *
     * @param id The id of the authorization rule to update.
     *
     * @return Exit code, 0 if authorization rule is updated successfully; 1
     * otherwise.
     */
    public int updateAllowableProvenance(final int id) {
        this.id = id;
        if (authorizationRule.getAllowableProvenances().contains(this))
            return 1;
        AllowableProvenance allowableProvenance = getDefinedAuthRule(
                authorizationRule, id);
        if (allowableProvenance == null)
            return 1;
        allowableProvenance.setDataProvenance(dataProvenance);
        allowableProvenance.setValidFrom(validFrom);
        allowableProvenance.setValidTo(validTo);
        allowableProvenance.update();
        allowableProvenance.authorizationRule.update();
        return 0;
    }

    /**
     * This method retrieves an authorization rule stored into
     * escrow agent's database associated with the type of data, data subject
     * and data controller defined by the object as well as unique id defined
     * by the method's parameter.
     *
     * @param authorizationRule Authorization rule.
     * @param id ID of authorization rule to be retrieved.
     *
     * @return Existing Authorization rule; otherwise null.
     */
    public static AllowableProvenance getDefinedAuthRule(
            final AuthorizationRule authorizationRule, final int id) {
        return AllowableProvenance.getFinder().where()
                .eq("authorizationRule.id", authorizationRule.getId())
                .eq("id", id)
                .findUnique();
    }

    /**
     * This method deletes an existing allowable provenance of data.
     *
     * Data subject deletes an allowable provenance which they have previously
     * defined. There is one extreme case: If there is only one allowable
     * provenance associated with a specific data type of a data subject and a
     * data controller, then deletion is completed only by locking these data to
     * data controller's update operations performed on these data.
     *
     * @param id The id of the provenance rule to delete.
     *
     * @return Exit code, 0 if provenance rule is deleted successfully; 1
     * otherwise.
     */
    public static int deleteAllowableProvenance(final int id) {
        AllowableProvenance allowableProvenance = AllowableProvenance
                .getFinder().where().eq("id", id).findUnique();
        if (allowableProvenance == null)
            return 1;
        if (allowableProvenance.getAuthorizationRule()
                .getAllowableActions().size() > 1) {
            allowableProvenance.delete();
            return 0;
        } else {
            allowableProvenance.setDefaultAuthRule();
            return 0;
        }
    }

    /**
     * This method sets default authorization rule.
     *
     * By default all authorization rules do not include any allowable
     * provenances where data can be obtained from.
     */
    public void setDefaultAuthRule() {
        final int infinityYear = 9999;
        final int day = 31;
        Calendar calendar = Calendar.getInstance();
        calendar.set(infinityYear, Calendar.DECEMBER, day);
        setDataProvenance(null);
        setValidFrom(new Date());
        setValidTo(calendar.getTime());
        update();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        AllowableProvenance that = (AllowableProvenance) o;

        return dataProvenance == that.dataProvenance
                && id != null ? !id.equals(that.id) : that.id != null;

    }

    @Override
    public int hashCode() {
        return dataProvenance != null ? dataProvenance.hashCode() : 0;
    }

    /**
     * Getter of id field.
     *
     * @return Id of entity.
     */
    public Integer getId() {
        return id;
    }

    /**
     * Getter of dataProvenance field
     *
     * @return The allowable source of data.
     */
    public DataProvenance getDataProvenance() {
        return dataProvenance;
    }

    /**
     * Setter of dataProvenance field.
     *
     * @param dataProvenance The allowable source of data.
     */
    public void setDataProvenance(final DataProvenance dataProvenance) {
        this.dataProvenance = dataProvenance;
    }

    /**
     * Getter of personalData field.
     *
     * @return Personal data associated with this authorization rule.
     */
    public AuthorizationRule getAuthorizationRule() {
        return authorizationRule;
    }

    /**
     * Getter of validFrom field.
     *
     * @return Date when authorization rule is valid from.
     */
    public Date getValidFrom() {
        return validFrom;
    }

    /**
     * Getter of validTo field.
     *
     * @return Date when authorization rule expires.
     */
    public Date getValidTo() {
        return validTo;
    }

    /**
     * Setter of validFrom field.
     *
     * @param validFrom Date when authorization rule is valid from.
     */
    public void setValidFrom(final Date validFrom) {
        this.validFrom = validFrom;
    }

    /**
     * Setter of validTo field.
     *
     * @param validTo Date when authorization rule expired.
     */
    public void setValidTo(final Date validTo) {
        this.validTo = validTo;
    }

    /**
     * Getter of finder field.
     *
     * @return It will be used to programatically make queries which return
     * object of this class.
     */
    public static Finder<Integer, AllowableProvenance> getFinder() {
        return finder;
    }
}
